package com.akchimwf.loftcoin1;

import android.app.Application;
import android.content.Context;

import androidx.annotation.NonNull;

import com.akchimwf.loftcoin1.data.CmcAPI;
import com.squareup.picasso.OkHttp3Downloader;
import com.squareup.picasso.Picasso;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.inject.Singleton;

import dagger.Module;
import dagger.Provides;
import okhttp3.Dispatcher;
import okhttp3.OkHttpClient;
import okhttp3.logging.HttpLoggingInterceptor;
import timber.log.Timber;

@Module
public abstract class AppModule {
    /*Scope annotation, default from Dagger. */
    /*We want AppModule @Provides method have to be @Singleton too -> Context dependency will be singleton and has lifecycle same with AppComponent.*/
    /*@Singleton annotation means app.getApplicationContext() will not call everytime, only once*/
    @Singleton   //@Modules can't be scoped, only @Provides methods inside
    @Provides
    static Context context(Application app) {
        return app.getApplicationContext();
    }

    @Singleton
    @Provides
    static ExecutorService ioExecutor() {
        /*classic formula to get pool size (number of threads that possible to run on current device)*/
        int poolSize = Runtime.getRuntime().availableProcessors() * 2 + 1;
        return Executors.newFixedThreadPool(poolSize);
    }

    /*this is base HttpClient for App*/
    @Singleton
    /*don't need to create OkHttpClient everytime as it takes time, only one instance of OkHttpClient needed in App(=AppComponent)
    and we have to keep it instance in AppComponent (OkHttpClient has states) */
    @Provides
    static OkHttpClient httpClient(ExecutorService executor) {
        final OkHttpClient.Builder builder = new OkHttpClient.Builder();

        /*OkHttpClient by default creates its own thread pool. But as we have own ExecutorService -> use it instead*/
        builder.dispatcher(new Dispatcher(executor));

        /*add logging Interceptor*/
        if (BuildConfig.DEBUG) {

            /*override of debug logging*/
            HttpLoggingInterceptor.Logger logger = new HttpLoggingInterceptor.Logger() {
                @Override
                public void log(@NonNull String message) {
                    Timber.d(message);  //here we can catch response from server in XML
                }
            };

            final HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor(logger);

            /*set to log HEADERS*/
            interceptor.setLevel(HttpLoggingInterceptor.Level.HEADERS);
            interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
            /*set NOT ot log API_KEY*/
            /*The logs generated by this interceptor when using the HEADERS or BODY levels
            have the potential to leak sensitive information such as "Authorization" or "Cookie" headers
            and the contents of request and response bodies. This com.akchimwf.loftcoin1.data should only be logged in a controlled way
            or in a non-production environment.
            You can redact headers that may contain sensitive information by calling redactHeader().*/
            interceptor.redactHeader(CmcAPI.API_KEY);

            builder.addInterceptor(interceptor);
        }

        /*return instance of OkHttpClient*/
        OkHttpClient client = builder.build();

        return client;
    }

    @Singleton
    @Provides
    /*preconfigured Picasso instance, using current HttpClient and Executor (Picasso will not create own)*/
    static Picasso picasso(Context context, OkHttpClient okHttpClient, ExecutorService executor) {
        return new Picasso.Builder(context)
                .downloader(new OkHttp3Downloader(okHttpClient))
                .executor(executor)
                .build();
    }

}
