package com.akchimwf.loftcoin1.ui.rates;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.navigation.fragment.NavHostFragment;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;

import com.akchimwf.loftcoin1.BaseComponent;
import com.akchimwf.loftcoin1.R;
import com.akchimwf.loftcoin1.databinding.FragmentRatesBinding;
import com.akchimwf.loftcoin1.databinding.LiRatesBinding;

import javax.inject.Inject;

import io.reactivex.disposables.CompositeDisposable;

public class RatesFragment extends Fragment {

    /*container with disposable objects - those objects which returns after subscription to RxJava stream*/
    private final CompositeDisposable disposable = new CompositeDisposable();

    /*FragmentRatesBinding class comes from 'viewBinding' at build.grade*/
    private FragmentRatesBinding binding;

    private final RatesComponent component;

    private RatesAdapter adapter;

    private RatesViewModel viewModel;
    private int bgCounter = 0;

    @Inject
    public RatesFragment(BaseComponent baseComponent) {
        /*get the RatesComponent in RatesFragment, setting BaseComponent as dependency*/
        /*DaggerRatesComponent.Builder autogenerated*/
        component = DaggerRatesComponent.builder()
                .baseComponent(baseComponent)
                .build();
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        /*when closing Fragment, it stays alive, only associated View is destroyed.
        So we keep adapter alive on the Fragment lifecycle. - PROBABLY IT'S NOT TRUE WHEN FRAGMENTS CREATING WITH NAVIGATION
        - THEY ARE CREATING EVERYTIME AGAIN*/
//        adapter = new RatesAdapter(new PriceFormatter(), new PercentFormatter());
        adapter = component.ratesAdapter();

        /*Creates ViewModelProvider. This will create ViewModels and retain them in a store of the given ViewModelStoreOwner.*/
        /*get -> Returns an existing ViewModel or creates a new one in the scope (usually, a fragment or an activity), associated with this ViewModelProvider.*/
        viewModel = new ViewModelProvider(this, component.viewModelFactory()).get(RatesViewModel.class);
    }

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        /*create View from current fragment layout*/
        return inflater.inflate(R.layout.fragment_rates, container, false);
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        /*set options menu*/
        setHasOptionsMenu(true);

        /*FragmentRatesBinding class comes from 'viewBinding' at build.grade*/
        /*don't inflate here, as we already inflated View in onCreateView. just bind View to FragmentRatesBinding*/
        binding = FragmentRatesBinding.bind(view);
        binding.recycler.setLayoutManager(new LinearLayoutManager(view.getContext()));

        /*Swaps the current adapter with the provided one.
        It is similar to setAdapter(RecyclerView.Adapter) but assumes existing adapter and the new adapter uses
        the same RecyclerView.ViewHolder and does not clear the RecycledViewPool.*/
        /*Params:
        adapter – The new adapter to set, or null to set no adapter.
        removeAndRecycleExistingViews – If set to true, RecyclerView will recycle all existing Views.
        If adapters have stable ids and/or you want to animate the disappearing views, you may prefer to set this to false.*/
        binding.recycler.swapAdapter(adapter, false);

        binding.recycler.setHasFixedSize(true);

        /*subscription and listing on IO thread, but result observe on main thread*/
        /*add returned Disposable reference to disposables list*/
        /*adapter::submitList subscribes on this stream*/
        disposable.add(viewModel.coins().subscribe(adapter::submitList));  //submitList - ListAdapter method -> Submits a new list to be diffed, and displayed.

        disposable.add(viewModel.isRefreshing().subscribe(binding.refresher::setRefreshing));

        binding.recycler.addOnChildAttachStateChangeListener(new RecyclerView.OnChildAttachStateChangeListener() {
            @Override
            public void onChildViewAttachedToWindow(@NonNull View view) {
                if (bgCounter++ % 2 == 0)
                    view.setBackgroundColor(getResources().getColor(R.color.dark_two));
                else view.setBackgroundColor(getResources().getColor(R.color.dark_six));
            }

            @Override
            public void onChildViewDetachedFromWindow(@NonNull View view) {

            }
        });

        binding.refresher.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                viewModel.refresh();
            }
        });
        /*could use also: */
        /*binding.refresher.setOnRefreshListener(viewModel::refresh);*/
    }

    @Override
    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
        inflater.inflate(R.menu.rates, menu);
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(@NonNull MenuItem item) {
//        Timber.d("%s", item);
        /*if clicked on currency in menu*/
        if (item.getItemId() == R.id.currency_dialog) {
            /*all navigation provided by Navigation controller -> we have to find it in current Fragment*/
            /*RatesFragment exists inside id/main_host fragment*/
            /*NavHostFragment provides an area within your layout for self-contained navigation to occur*/
            /*we sure that we can get Navigation controller from current Fragment*/
            NavHostFragment.findNavController(this)
                    /*RatesFragment don't know which Fragment will be shown on click -> no direct connections between fragments*/
                    /*can replace currency_dialog in Navigation graph without any problems with dependencies*/
                    .navigate(R.id.currency_dialog);
            return true;
            /*if clicked on sort in menu*/
        } else if (item.getItemId() == R.id.sort_dialog) {
            viewModel.switchSortingOrder();
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onDestroyView() {
        /*when closing Fragment, it stays alive, only associated View is destroyed.
        So we keep adapter alive on the Fragment lifecycle. - PROBABLY IT'S NOT TRUE WHEN FRAGMENTS CREATING WITH NAVIGATION
        - THEY ARE CREATING EVERYTIME AGAIN*/
        binding.recycler.swapAdapter(null, false); //else GC will not collect RV

        /*Atomically clears the container, then disposes all the previously contained Disposables.*/
        /*not .dispose() as this method will destroy  CompositeDisposable -> should not happened onDestroyView*/
        disposable.clear();  //unsubscribe all disposable objects in container

        super.onDestroyView();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }
}